name: Sync Upstream

on:
  schedule:
    # 每天 UTC 0:00 (北京时间 8:00) 自动同步
    - cron: '0 0 * * *'
  workflow_dispatch:  # 支持手动触发

jobs:
  sync:
    name: Sync with upstream
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        submodules: recursive
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Configure Git
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
    
    - name: Add upstream remote
      run: |
        git remote add upstream https://github.com/ztxz16/fastllm.git || true
        git fetch upstream
    
    - name: Sync upstream changes
      id: sync
      run: |
        # 获取上游 master 分支的最新提交
        UPSTREAM_COMMIT=$(git rev-parse upstream/master)
        LOCAL_UPSTREAM=$(git merge-base HEAD upstream/master 2>/dev/null || echo "none")

        # 记录合并前的本地 HEAD，用于在合并后恢复本地 Windows 定制文件
        LOCAL_HEAD=$(git rev-parse HEAD)

        # 需要强制保留的本地文件：
        # 1) 固定的 Windows fork 定制文件白名单
        # 2) 动态生成：本地分支相对 upstream/master 的全部差异文件（防止上游覆盖本地改动）
        PROTECTED_BASE=(
          .github/
          build.ps1
          ftllm.cpp
          CMakeLists.txt
          README.md
          README_EN.md
          docs/使用说明.md
          .gitmodules
        )

        # 动态差异文件：列出本地分支相对 upstream/master 的改动文件（新增/修改/删除都会列出）
        mapfile -t PROTECTED_DYNAMIC < <(git diff --name-only upstream/master...HEAD || true)

        # 合并去重（保持顺序）
        PROTECTED_FILES=()
        declare -A _seen
        for f in "${PROTECTED_BASE[@]}" "${PROTECTED_DYNAMIC[@]}"; do
          if [ -n "$f" ] && [ -z "${_seen[$f]+x}" ]; then
            _seen[$f]=1
            PROTECTED_FILES+=("$f")
          fi
        done
        
        echo "Upstream latest: $UPSTREAM_COMMIT"
        echo "Local base: $LOCAL_UPSTREAM"
        
        if [ "$UPSTREAM_COMMIT" != "$LOCAL_UPSTREAM" ]; then
          echo "New changes detected from upstream"
          
          # 合并上游更改（总体偏向上游，随后会强制恢复本地定制文件）
          git merge upstream/master --no-edit -X theirs || {
            # 如果有冲突：对保护文件保留 ours，其余按 merge 结果处理
            git checkout --ours "${PROTECTED_FILES[@]}" 2>/dev/null || true
            git add -A
            git commit -m "Merge upstream with local Windows customizations" || true
          }

          # 合并完成后：强制把保护文件恢复到合并前本地版本，避免被上游覆盖
          git checkout "$LOCAL_HEAD" -- "${PROTECTED_FILES[@]}" 2>/dev/null || true
          if ! git diff --quiet; then
            git add -A
            git commit -m "chore: Restore local Windows customizations after upstream merge" || true
          fi
          
          echo "SYNCED=true" >> $GITHUB_ENV
          echo "synced=true" >> $GITHUB_OUTPUT
        else
          echo "Already up to date with upstream"
          echo "SYNCED=false" >> $GITHUB_ENV
          echo "synced=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Push upstream sync
      if: steps.sync.outputs.synced == 'true'
      run: |
        git push origin master
    
    - name: Update submodules
      id: submodules
      run: |
        echo "=== Checking submodule updates ==="
        
        # 更新子模块到远程最新版本
        git submodule update --remote --merge
        
        # 检查是否有变更
        if git diff --quiet; then
          echo "Submodules are up to date"
          echo "SUBMODULES_UPDATED=false" >> $GITHUB_ENV
          echo "updated=false" >> $GITHUB_OUTPUT
        else
          echo "Submodules updated"
          git add .
          git commit -m "chore: Auto-update submodules (pybind11, sentencepiece)"
          echo "SUBMODULES_UPDATED=true" >> $GITHUB_ENV
          echo "updated=true" >> $GITHUB_OUTPUT
          git push origin master
        fi
    
    - name: Create sync summary
      run: |
        if [ "$SYNCED" == "true" ]; then
          echo "✅ Successfully synced with upstream ztxz16/fastllm"
        else
          echo "ℹ️ No new changes from upstream"
        fi
        
        if [ "$SUBMODULES_UPDATED" == "true" ]; then
          echo "✅ Submodules updated to latest versions"
        else
          echo "ℹ️ Submodules are already up to date"
        fi
    
    outputs:
      synced: ${{ steps.sync.outputs.synced }}
      submodules_updated: ${{ steps.submodules.outputs.updated }}

  # 当有上游更新时触发构建
  trigger-build:
    name: Trigger Build
    needs: sync
    if: needs.sync.outputs.synced == 'true' || needs.sync.outputs.submodules_updated == 'true'
    uses: ./.github/workflows/build-windows.yml
    with:
      build_cpu: true
      build_cuda: true
    secrets: inherit
